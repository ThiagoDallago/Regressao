# -*- coding: utf-8 -*-
"""House_Prices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16_x9F0NFkZflwH7oGz8aDVx0Gpmn2OVB

#Introdução

O presente projeto tem por objetivo a aplicação de modelo de Regressão
para prever o preço de venda de casas.
o dataset conta com 79 variáveis ​​explicativas descrevendo (quase) todos os aspectos dos imóveis residenciais em Ames, Iowa.

#Entendimento do Problema de negócio

Trata-se de problema de precificação de imóveis — ou seja, deseja prever o valor de venda de uma casa com base em suas características físicas, localização, infraestrutura, entre outros.

Objetivo de negócio:
Ajudar construtoras, imobiliárias, compradores, corretores e investidores a estimarem corretamente o valor de um imóvel com base em dados históricos. Isso pode:

* Otimizar o preço de venda, maximizando o lucro e reduzindo o tempo no mercado.

* Evitar subavaliação ou superavaliação de imóveis.

* Auxiliar bancos na avaliação de garantias de crédito imobiliário.

* Automatizar processos em plataformas digitais de venda e aluguel de imóveis.

# Entendimento dos Dados
"""

### Bibliotecas
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

from warnings import filterwarnings
filterwarnings('ignore')
pd.set_option('display.max_columns',None)
pd.set_option('display.max_rows', None)

"""#### Lendo os dados disponibilizados"""

df_train = pd.read_csv ('/content/drive/MyDrive/PodAcademy/Tarefas/Regressao/House_Prices/train.csv')

df_test = pd.read_csv ('/content/drive/MyDrive/PodAcademy/Tarefas/Regressao/House_Prices/test.csv')

# verificando a quantidade de linhas e colunas

print(f"O dataframe possui {df_train.shape[0]} linhas e {df_train.shape[1]} colunas. ")

df_train.head()

df_train.tail()

# Metadados

# Construindo função para obter metadados
def metadados(dataframe):
    """
    Gera um dataframe contendo metadados das colunas do dataframe fornecido.

    :dataframe: DataFrame para o qual os metadados serão gerados.
    :return: DataFrame contendo metadados.
    """

    # Coleta de metadados básicos
    metadata = pd.DataFrame({
        'nome_variavel': dataframe.columns,
        'tipo': dataframe.dtypes,
        'qt_nulos': dataframe.isnull().sum(),
        'percent_nulos': round((dataframe.isnull().sum() / len(dataframe))* 100,2),
        'cardinalidade': dataframe.nunique(),
    })
    metadata = metadata.sort_values(by='tipo',ascending=False)
    metadata = metadata.reset_index(drop=True)

    return metadata

# Obtendo metadados

metadados_df = metadados(df_train)
metadados_df.head(100)

# Análise estatística para os dados numéricos

df_train.describe().T

# Análise das variáveis qualitativas

df_train.describe(include=["object"]).T

# Distribuição dos preços de venda
sns.histplot(df_train['SalePrice'], kde=True)
plt.title("Distribuição do Preço de Venda")
plt.show()

# Análise estatística para a variável target
df_train['SalePrice'].describe()

"""### Quais variáveis possuem maior correlação com SalePrice?"""

### verificando a correlação entre variáveis

numeric_df = df_train.select_dtypes(include=['int64', 'float64'])
numeric_df = numeric_df.drop(columns=['Id'])

# Correlação com SalePrice
correlations = numeric_df.corr(method='pearson')['SalePrice'].sort_values(ascending=False)
correlations

"""### Quais regiões tem as casas mais valorizadas?"""

# Top 10 bairos mais valorizados

bairro_valorizado_df = (
    df_train.groupby('Neighborhood', as_index=False)
    .agg(
        Preco_Medio_Venda=('SalePrice', 'mean'),
        Qtde_Casas=('SalePrice', 'count')
    )
    .sort_values(by='Preco_Medio_Venda', ascending=False)
    .reset_index(drop=True)  # Corrigir o índice
)

# Exibir os top 10 bairros mais valorizados
top_10_bairros = bairro_valorizado_df.head(10)
top_10_bairros

# Definir o estilo do gráfico
sns.set(style="whitegrid")

# Criar o gráfico de barras
plt.figure(figsize=(12, 6))
sns.barplot(
    data=top_10_bairros,
    x='Neighborhood',
    y='Preco_Medio_Venda',
    palette='mako'
)

# Adicionar rótulos e título
plt.title('Top 10 Bairros Mais Valorizados', fontsize=16)
plt.xlabel('Bairro', fontsize=12)
plt.ylabel('Preço Médio de Venda (USD)', fontsize=12)
plt.xticks(rotation=45)

# Exibir o gráfico
plt.tight_layout()
plt.show()

""" ### Existe sazonalidade nas vendas?"""

# Ajustar estilo do gráfico
sns.set(style="whitegrid")

# Contagem de imóveis vendidos por mês
vendas_por_mes = df_train['MoSold'].value_counts().sort_index()

# Gráfico de barras
plt.figure(figsize=(10, 6))
sns.barplot(x=vendas_por_mes.index, y=vendas_por_mes.values, palette='mako')

plt.title('Quantidade de Imóveis Vendidos por Mês', fontsize=14)
plt.xlabel('Mês da Venda (1 = Jan, ..., 12 = Dez)', fontsize=12)
plt.ylabel('Número de Vendas', fontsize=12)
plt.xticks(range(0, 12), ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'])
plt.tight_layout()
plt.show()

"""### Qual o preço médio por mês"""

# Calcular preço médio de venda por mês
preco_medio_mes = df_train.groupby('MoSold')['SalePrice'].mean()

# Visualizar
preco_medio_mes.plot(kind='bar', figsize=(10,5), color='skyblue')
plt.title('Preço Médio de Venda por Mês')
plt.xlabel('Mês (1 = Jan, ..., 12 = Dez)')
plt.ylabel('Preço Médio de Venda (USD)')
plt.xticks(ticks=range(0, 12), labels=['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'], rotation=45)
plt.tight_layout()
plt.show()

"""### Os bairros com maior valorização são os mesmos que mais vendem em maio–julho?"""

# Filtrar os meses de interesse: maio (5), junho (6), julho (7)
meses_pico = [5, 6, 7]
df_pico = df_train[df_train['MoSold'].isin(meses_pico)]

# Agrupar e contar o número de vendas por bairro nesses meses
vendas_pico_bairro = (
    df_pico.groupby('Neighborhood')['SalePrice']
    .count()
    .reset_index(name='Vendas_Maio_Jun_Jul')
)

# Calcular o preço médio por bairro (base geral)
preco_medio_bairro = (
    df_train.groupby('Neighborhood')['SalePrice']
    .mean()
    .reset_index(name='Preco_Medio_Venda')
)

# Unir os dois DataFrames
analise_bairros = pd.merge(preco_medio_bairro, vendas_pico_bairro, on='Neighborhood', how='left')

# Preencher bairros sem venda nesses meses com 0
analise_bairros['Vendas_Maio_Jun_Jul'] = analise_bairros['Vendas_Maio_Jun_Jul'].fillna(0).astype(int)

# Ordenar pelos bairros mais valorizados
analise_bairros = analise_bairros.sort_values(by='Preco_Medio_Venda', ascending=False).reset_index(drop=True)

# Visualizar os top 10
analise_bairros.head(10)

"""### Quais foram os bairros que mais venderam nos meses de Maio a Junho?"""

# Filtrar os meses de interesse: maio (5), junho (6), julho (7)
meses_pico = [5, 6, 7]
df_pico = df_train[df_train['MoSold'].isin(meses_pico)]

# Contar número de vendas por bairro nesses meses
bairros_mais_vendas_pico = (
    df_pico['Neighborhood']
    .value_counts()
    .reset_index()
    .rename(columns={'index': 'Neighborhood', 'Neighborhood': 'Total_Vendas_Maio_Jun_Jul'})
)

# Exibir os top 10 bairros com mais vendas nesses meses
bairros_mais_vendas_pico.head(10)